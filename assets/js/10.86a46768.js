(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{364:function(e,t,a){"use strict";a.r(t);var n=a(41),s=Object(n.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h2",{attrs:{id:"let-和const-块级作用域"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#let-和const-块级作用域"}},[e._v("#")]),e._v(" let 和const 块级作用域")]),e._v(" "),a("h2",{attrs:{id:"解构赋值-数组、对象"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#解构赋值-数组、对象"}},[e._v("#")]),e._v(" 解构赋值 数组、对象")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[e._v("    //返回多个值\n    let {foo , bar} = example()\n    function example() {\n        return {\n        foo:1,\n        bar:2\n        }\n    }\n    //提取json数据\n    let {id,status,data:number} = jsonData\n    //展开\n    [...obj] \n")])])]),a("h2",{attrs:{id:"函数作用域-箭头函数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#函数作用域-箭头函数"}},[e._v("#")]),e._v(" 函数作用域，箭头函数")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[e._v("    第一题\n    function foo() {\n        console.log(a);\n        a = 1;\n    }\n    \n    foo(); // ???\n    \n    function bar() {\n        a = 1;\n        console.log(a);\n    }\n    bar(); // ???\n")])])]),a("p",[e._v("第一段会报错：Uncaught ReferenceError: a is not defined。")]),e._v(" "),a("p",[e._v("第二段会打印：1。")]),e._v(" "),a("p",[e._v('这是因为函数中的 "a" 并没有通过 var 关键字声明，所有不会被存放在 AO 中。\n第一段执行 console 的时候， AO 的值是：')]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[e._v("    AO = {\n        arguments: {\n            length: 0\n        }\n    }\n")])])]),a("p",[e._v("没有 a 的值，然后就会到全局去找，全局也没有，所以会报错。")]),e._v(" "),a("p",[e._v("当第二段执行 console 的时候，全局对象已经被赋予了 a 属性，这时候就可以从全局找到 a 的值，所以会打印 1。")]),e._v(" "),a("p",[e._v("第二题")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[e._v('    console.log(foo);\n    \n    function foo(){\n        console.log("foo");\n    }\n    \n    var foo = 1;\n')])])]),a("p",[e._v("会打印函数，而不是 undefined 。\n这是因为在进入执行上下文时，首先会处理函数声明，其次会处理变量声明，如果变量名称跟已经声明的形式参数或函数相同，则变量声明不会干扰已经存在的这类属性。")]),e._v(" "),a("h2",{attrs:{id:"合并对象"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#合并对象"}},[e._v("#")]),e._v(" 合并对象")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[e._v("    const target = { a: 1 };\n    const source1 = { b: 2 };\n    const source2 = { c: 3 };\n    Object.assign(target, source1, source2);\n    target // {a:1, b:2, c:3}\n")])])]),a("h2",{attrs:{id:"symbol是不会重复的值-第七种基本数据结构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#symbol是不会重复的值-第七种基本数据结构"}},[e._v("#")]),e._v(" symbol是不会重复的值，第七种基本数据结构")]),e._v(" "),a("p",[e._v("六种基本类型undefined、boolean、number、string、null、symbol")]),e._v(" "),a("p",[e._v("set集合和map字典\n都不允许相同\n都有增 删has，遍历\nset类数组，key values一样。Array.from()方法转数组。[.. . set]也可。add\nnew Map([1,2,3])")]),e._v(" "),a("p",[e._v("map类对象，键可以是任何类型，而对象键只能是符串。get set\nmap转数组也是[.. . map]。转对象则遍历set")]),e._v(" "),a("p",[e._v("for in和for of\nof是获取值，只遍历实例属性，不遍历原型。主用于数组，map set generator。\nin是获取键名，主要用于对象，会遍历原型，效低。")]),e._v(" "),a("h2",{attrs:{id:"proxy"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#proxy"}},[e._v("#")]),e._v(" Proxy")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[e._v("    var obj = new Proxy({},{\n    get: func\n    set: func\n    })\n    obj.count=1\n    //对Proxy实例操作才会生效\n")])])]),a("p",[e._v("Reflect")]),e._v(" "),a("p",[e._v("将Object对象的一些明显属于语言内部的方法放到Reflect对象上。比如Object.defineProperty")]),e._v(" "),a("h2",{attrs:{id:"promise"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#promise"}},[e._v("#")]),e._v(" Promise")]),e._v(" "),a("p",[e._v("Promise对象的状态不受外界影响，只有异步操作的结果可以决定当前是哪种状态，其他任何操作都无法改变这个状态；一旦状态改变就不会再变。")]),e._v(" "),a("p",[e._v("new一个Promise对象,接受resolve和reject两个函数作为参数。Promise new之后会立即执行，如resolve则会调用then回调。")]),e._v(" "),a("p",[e._v("Promise中任何一个抛出的错误都会被最后一个catch捕获。如果promise链上某个步骤抛出了错误但是后面没有catch方法了，会导致这个错误不会被捕获也不会传递到外层。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[e._v("    var p = Promise.all([p1,p2,p3]) //三个都resolv或者有一个reject触发回调\n\n    var p = Promise.race([p1,p2,p3]) //只要有一个状态改变就会触发回调\n")])])]),a("p",[e._v("Promise.resolve() 可以直接返回一个Resolved状态的Promise对象")]),e._v(" "),a("p",[e._v("Promise.reject()")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[e._v("    new Promise((resolve,reject) => {\n    resolve(1);\n    cosole.log(2)\n    }).then(r=>{\n    console.log(r)\n    })\n    //2\n    //1\n    \n    new Promise((resolve,reject)=> {\n    return resolve(1);\n    //后面的不会执行\n    console.log(2)\n    })\n")])])]),a("p",[e._v("axios取消请求。提供了api用来取消cancelToken。原理是在peomise里暴露一个回调函数直接resolve。")]),e._v(" "),a("h2",{attrs:{id:"iterator和for-of循环"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#iterator和for-of循环"}},[e._v("#")]),e._v(" Iterator和for of循环")]),e._v(" "),a("p",[e._v("遍历器对象有next()方法，每次调用返回{value:  done:  }。ES6规定默认的Iteratorj接口部署再数据结构的Symbol.iterator属性。是个fuc")]),e._v(" "),a("p",[e._v("具备Iterator的数据结构\nArray、Map、Set、String、函数的arguments对象、NodeList对象")]),e._v(" "),a("p",[e._v("数组、set、map部署了，都返回遍历器对象\nentries() [键名，键值]，map的iterator接口默认就是调用entries方法。keys() 建名values() 键值")]),e._v(" "),a("h2",{attrs:{id:"generator"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#generator"}},[e._v("#")]),e._v(" Generator")]),e._v(" "),a("p",[e._v("yield 是暂停标志，next()方法恢复执行。\nGenerator函数 （）执行返回一个遍历器对象，再调用next（）才会执行。执行到yield标志处，将yield后的值，表达式求值，函数则会执行。然后将值以{value: 值,done: }的形式返回。")]),e._v(" "),a("p",[e._v("co自动执行函数，yield后面要是promise。只要g函数还没执行到最后一步，next函数就调用自身。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[e._v("    function run(gen) {\n        var g = gen()\n        function next(data) {\n            var result = g.next(data);\n            if(result.done) return result.value\n            result.value.then(function(data){\n                next(data)\n            })\n        }\n        next()\n    }\n")])])]),a("h2",{attrs:{id:"async"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#async"}},[e._v("#")]),e._v(" async")]),e._v(" "),a("p",[e._v("语法糖，将Generator函数和自动执行器包装在一个函数里。")]),e._v(" "),a("p",[e._v("yield后面可以是原始类型的值，会被转成一个立即resolve的promise，此时等同于同步操作。")]),e._v(" "),a("p",[e._v("async函数里有多个await，只要有一个await后面的promise变成了reject，那么整个async函数都会中断执行")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[e._v("    let [foo,bar] = await Promise.all([getFoo(),getBar()])\n")])])]),a("h2",{attrs:{id:"class-extend"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#class-extend"}},[e._v("#")]),e._v(" class extend")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[e._v("    class Point{\n    constructor(x,y) {\n    this.x\n    }\n    toString() {}\n    }\n")])])]),a("p",[e._v("class中的constructor就是ES5里的构造函数，其他方法直接定义在原型Point.prototype上。")]),e._v(" "),a("p",[e._v("Object.assign(Point.prototype,{toString(){}})可往原型上添加方法。")]),e._v(" "),a("p",[e._v("p.hasOwnProperty('')可以判断变量或者方法是否在实例对象p上。")]),e._v(" "),a("p",[e._v("class里加static表示该定义在该类上的静态属性 方法，Point.toString()可以调用，new的实例上无法调用。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[e._v("    class CPoint extends Point {\n        constructor(x,y,color) {\n            super(x,y);\n            this.color = color;\n        }\n        toString() {\n            return this.color + '' + super.toSting()\n        }\n    }\n")])])]),a("p",[e._v("super()表示调用父类的构造函数，用来新建父类的this对象。")]),e._v(" "),a("p",[e._v("ES5的继承是先创造子类的实例对象this然后将父类的方法添加到this上面（Parent）.ES6的继承是先创造父类的实例对象然后再用字类的构造函数修改this对其进行加工。必须先在构造方法里调用super方法，才能使用this关键字。")])])}),[],!1,null,null,null);t.default=s.exports}}]);